# Авторизация в micro-stt

## Обзор

Начиная с версии 0.9.0, эндпоинты транскрипции могут быть защищены Bearer token авторизацией. Это обеспечивает контроль доступа к API и предотвращает несанкционированное использование сервиса.

Начиная с версии 0.10.0, встроенная авторизация **по умолчанию отключена** (`AUTH_ENABLED=false`), что позволяет гибко использовать внешние системы авторизации (API Gateway, reverse proxy, service mesh).

## Конфигурация

### Переменная окружения AUTH_ENABLED

Переменная `AUTH_ENABLED` управляет включением/выключением встроенной авторизации (по умолчанию `false`):

```bash
# Отключить встроенную авторизацию (по умолчанию)
AUTH_ENABLED=false

# Включить встроенную авторизацию
AUTH_ENABLED=true
```

### Переменная окружения AUTH_TOKENS

Переменная `AUTH_TOKENS` является **обязательной только когда `AUTH_ENABLED=true`** и должна содержать один или несколько токенов авторизации, разделённых запятыми:

```bash
AUTH_TOKENS=token1,token2,secret-key-123
```

**Важно:**

- Пробелы вокруг токенов автоматически удаляются
- Пустые токены игнорируются
- Должен быть указан хотя бы один непустой токен, когда `AUTH_ENABLED=true`
- Сервис не запустится, если `AUTH_ENABLED=true` и `AUTH_TOKENS` не задан или пуст
- Когда `AUTH_ENABLED=false`, переменная `AUTH_TOKENS` игнорируется и не требуется

## Использование

### Формат запроса

Для доступа к защищённым эндпоинтам передавайте токен в заголовке `Authorization` в формате Bearer:

```bash
Authorization: Bearer YOUR_TOKEN
```

### Пример curl запроса

```bash
curl -X POST http://localhost:3000/api/v1/transcriptions/file \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer your-secret-token' \
  -d '{
    "audioUrl": "https://example.com/audio.mp3"
  }'
```

## Защищённые эндпоинты

Авторизация требуется для всех эндпоинтов в группе `/api/v1/transcriptions/*`:

- `POST /api/v1/transcriptions/file` — транскрибация аудио файла

## Публичные эндпоинты

Следующие эндпоинты остаются **публичными** и не требуют авторизации:

- `GET /api/v1` — индекс API
- `GET /api/v1/health` — проверка здоровья сервиса
- `GET /api/v1/health/ready` — readiness probe
- `GET /api/v1/health/live` — liveness probe

## Отключение встроенной авторизации

### Когда использовать AUTH_ENABLED=false

Отключите встроенную авторизацию в следующих случаях:

1. **API Gateway:** Когда авторизация реализована на уровне API Gateway (Kong, AWS API Gateway, Azure API Management и т.п.)
2. **Reverse Proxy:** Когда авторизация обрабатывается reverse proxy (nginx, Traefik, Envoy)
3. **Service Mesh:** Когда авторизация реализована в service mesh (Istio, Linkerd)
4. **Корпоративная сеть:** Когда сервис доступен только внутри защищённой корпоративной сети
5. **Тестирование/Разработка:** Для упрощения локальной разработки и тестирования

### Пример конфигурации без авторизации

```bash
# .env
AUTH_ENABLED=false
# AUTH_TOKENS не требуется
```

**⚠️ Предупреждение:** При отключении встроенной авторизации убедитесь, что авторизация реализована на другом уровне. Никогда не отключайте авторизацию в production без альтернативного механизма защиты.

## Обработка ошибок

### 401 Unauthorized

Возвращается в следующих случаях (только когда `AUTH_ENABLED=true`):

1. **Отсутствует заголовок Authorization:**

   ```json
   {
     "statusCode": 401,
     "message": "Missing Authorization header",
     "error": "Unauthorized"
   }
   ```

2. **Неверный формат заголовка:**

   ```json
   {
     "statusCode": 401,
     "message": "Invalid Authorization header format. Expected: Bearer <token>",
     "error": "Unauthorized"
   }
   ```

3. **Невалидный токен:**
   ```json
   {
     "statusCode": 401,
     "message": "Invalid authorization token",
     "error": "Unauthorized"
   }
   ```

## Swagger UI

Bearer авторизация полностью интегрирована в Swagger UI:

1. Откройте `http://localhost:3000/api/docs`
2. Нажмите кнопку **Authorize** в правом верхнем углу
3. Введите ваш токен (без префикса "Bearer")
4. Нажмите **Authorize**
5. Теперь все запросы через Swagger UI будут автоматически включать токен авторизации

## Безопасность

### Рекомендации

1. **Генерация токенов:** Используйте криптографически стойкие генераторы случайных чисел для создания токенов
2. **Длина токенов:** Рекомендуется минимум 32 символа
3. **Хранение:** Храните токены в защищённом хранилище секретов (не коммитьте в git)
4. **HTTPS:** В продакшене всегда используйте HTTPS для защиты токенов при передаче
5. **Ротация:** Регулярно меняйте токены и обновляйте переменную окружения
6. **Мониторинг:** Отслеживайте неудачные попытки авторизации в логах

### Генерация безопасного токена

Пример генерации случайного токена:

```bash
# Linux/macOS
openssl rand -base64 32

# Node.js
node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
```

## Особенности реализации

- **Guard:** Используется `AuthGuard` (NestJS Guard)
- **Проверка:** Простое сравнение токена со списком разрешённых
- **Регистрозависимость:** Токены регистрозависимы
- **Производительность:** Минимальные накладные расходы на каждый запрос
- **Логирование:** Неудачные попытки авторизации логируются с уровнем WARN

## Миграция с версии < 0.9.0

Если вы обновляетесь с версии до 0.9.0:

1. Сгенерируйте один или несколько безопасных токенов
2. Добавьте переменную `AUTH_TOKENS` в `.env` файл или окружение
3. Обновите все клиентские приложения для передачи токена в заголовке `Authorization`
4. Перезапустите сервис
5. Проверьте работоспособность с помощью health check эндпоинтов (публичные)
6. Протестируйте авторизацию с валидным токеном

## Тестирование

Для тестирования авторизации доступны unit и e2e тесты:

```bash
# Unit тесты AuthGuard
pnpm test -- auth.guard.spec.ts

# E2E тесты авторизации
pnpm test:e2e -- auth.e2e-spec.ts

# Все тесты
pnpm test && pnpm test:e2e
```

## FAQ

**Q: Можно ли использовать один и тот же токен для разных клиентов?**  
A: Да, но рекомендуется выдавать уникальные токены для каждого клиента или сервиса для лучшей трассируемости и возможности отзыва.

**Q: Поддерживаются ли другие схемы авторизации (Basic, Digest)?**  
A: Нет, поддерживается только Bearer токены.

**Q: Можно ли отключить авторизацию?**  
A: Да, установите `AUTH_ENABLED=false`. Используйте это только при наличии внешней авторизации на уровне API Gateway, reverse proxy или service mesh.

**Q: Что происходит при AUTH_ENABLED=false?**  
A: Все запросы к эндпоинтам транскрипции разрешаются без проверки токена. `AUTH_TOKENS` не требуется. Убедитесь, что авторизация реализована на другом уровне.

**Q: Есть ли rate limiting?**  
A: Нет, встроенный rate limiting удален. Рекомендуется реализовать rate limiting на уровне API Gateway или reverse proxy.

**Q: Логируются ли использованные токены?**  
A: Нет, токены не логируются в целях безопасности. Логируются только факты успешной/неудачной авторизации.
